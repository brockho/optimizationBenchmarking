package org.optimizationBenchmarking.utils.io.structured.impl.abstr;

import java.io.OutputStream;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.zip.Deflater;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import org.optimizationBenchmarking.utils.io.encoding.StreamEncoding;
import org.optimizationBenchmarking.utils.io.paths.PathUtils;
import org.optimizationBenchmarking.utils.io.structured.spec.IStreamOutputJobBuilder;
import org.optimizationBenchmarking.utils.io.structured.spec.IStreamOutputTool;

/**
 * A tool for generating stream output. The contents generated by this tool
 * are always a single file or stream of data.
 * 
 * @param <S>
 *          the source type
 */
public class StreamOutputTool<S> extends FileOutputTool<S> implements
    IStreamOutputTool<S> {

  /** create */
  protected StreamOutputTool() {
    super();
  }

  /** {@inheritDoc} */
  @Override
  final void _checkRawStreams() {
    // well, we can handle raw streams now
  }

  /**
   * Obtain the default name for a plain file to write to if the
   * destination path specifies a directory or ZIP archive
   * 
   * @return the default file name
   */
  protected String getDefaultPlainOutputFileName() {
    return "output.file"; //$NON-NLS-1$
  }

  /** {@inheritDoc} */
  @Override
  final void _path(final IOJob job, final S data, final Path path,
      final BasicFileAttributes attributes,
      final StreamEncoding<?, ?> encoding, final boolean zipped)
      throws Throwable {
    Path file;

    if ((attributes != null) && (attributes.isDirectory())) {
      file = PathUtils.createPathInside(
          path,
          (zipped ? this.getDefaultZIPOutputFileName() : this
              .getDefaultPlainOutputFileName()));
      job.log("Path '" + path + //$NON-NLS-1$
          "' identifies a directory, creating file '" //$NON-NLS-1$
          + file + "' for output.");//$NON-NLS-1$
    } else {
      file = path;
    }

    try (final OutputStream fileOutput = PathUtils.openOutputStream(file)) {
      this._stream(job, data, fileOutput, encoding, zipped);
    }
  }

  /** {@inheritDoc} */
  @Override
  final void _stream(final IOJob job, final S data,
      final OutputStream stream, final StreamEncoding<?, ?> encoding,
      final boolean zipCompress) throws Throwable {
    String name;

    if (zipCompress) {
      name = this.getDefaultPlainOutputFileName();
      if (job.canLog()) {
        job.log("Creating ZIP-compressed output with file '" + name //$NON-NLS-1$
            + "' as the data (and only) file in the compressed stream."); //$NON-NLS-1$
      }
      try (final ZipOutputStream zipStream = new ZipOutputStream(stream)) {
        zipStream.setMethod(ZipOutputStream.DEFLATED);
        zipStream.setLevel(Deflater.BEST_COMPRESSION);
        zipStream.putNextEntry(new ZipEntry(name));
        this.__stream(job, data, zipStream, encoding);
        zipStream.closeEntry();
      }
    } else {
      this.__stream(job, data, stream, encoding);
    }
  }

  /**
   * Store the data element to a stream
   * 
   * @param job
   *          the job where logging info can be written
   * @param data
   *          the data to be written
   * @param stream
   *          the stream
   * @param encoding
   *          the encoding
   * @throws Throwable
   */
  private final void __stream(final IOJob job, final S data,
      final OutputStream stream, final StreamEncoding<?, ?> encoding)
      throws Throwable {
    Class<?> clazz;

    if ((encoding != null) && (encoding != StreamEncoding.UNKNOWN)
        && (encoding != StreamEncoding.TEXT)
        && (encoding != StreamEncoding.BINARY)
        && ((clazz = encoding.getOutputClass()) != null)
        && OutputStream.class.isAssignableFrom(clazz)) {
      if (job.canLog(IOJob.FINE_LOG_LEVEL)) {
        job.log(IOJob.FINE_LOG_LEVEL,
            "Using byte stream encoding " + encoding.name()); //$NON-NLS-1$
      }
      try (OutputStream encoded = ((OutputStream) (encoding
          .wrapOutputStream(stream)))) {
        this.stream(job, data, encoded, StreamEncoding.UNKNOWN);
      }
    } else {
      this.stream(job, data, stream, encoding);
    }
  }

  /**
   * Store the data element to a stream
   * 
   * @param job
   *          the job where logging info can be written
   * @param data
   *          the data to be written
   * @param stream
   *          the stream
   * @param encoding
   *          the encoding
   * @throws Throwable
   */
  protected void stream(final IOJob job, final S data,
      final OutputStream stream, final StreamEncoding<?, ?> encoding)
      throws Throwable {
    //
  }

  /** {@inheritDoc} */
  @SuppressWarnings({ "unchecked", "rawtypes" })
  @Override
  public IStreamOutputJobBuilder<S> use() {
    this.beforeUse();
    return new _StreamOutputJobBuilder(this);
  }
}
