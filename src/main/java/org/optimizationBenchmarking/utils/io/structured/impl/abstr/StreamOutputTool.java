package org.optimizationBenchmarking.utils.io.structured.impl.abstr;

import java.io.OutputStream;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;

import org.optimizationBenchmarking.utils.io.EArchiveType;
import org.optimizationBenchmarking.utils.io.encoding.StreamEncoding;
import org.optimizationBenchmarking.utils.io.paths.PathUtils;
import org.optimizationBenchmarking.utils.io.structured.spec.IStreamOutputJobBuilder;
import org.optimizationBenchmarking.utils.io.structured.spec.IStreamOutputTool;

/**
 * A tool for generating stream output. The contents generated by this tool
 * are always a single file or stream of data.
 * 
 * @param <S>
 *          the source type
 */
public class StreamOutputTool<S> extends FileOutputTool<S> implements
    IStreamOutputTool<S> {

  /** create */
  protected StreamOutputTool() {
    super();
  }

  /** {@inheritDoc} */
  @Override
  final void _checkRawStreams() {
    // well, we can handle raw streams now
  }

  /**
   * Obtain the default name for a plain file to write to if the
   * destination path specifies a directory or ZIP archive
   * 
   * @return the default file name
   */
  protected String getDefaultPlainOutputFileName() {
    return "output.file"; //$NON-NLS-1$
  }

  /** {@inheritDoc} */
  @Override
  final void _path(final IOJob job, final S data, final Path path,
      final BasicFileAttributes attributes,
      final StreamEncoding<?, ?> encoding, final EArchiveType archiveType)
      throws Throwable {
    final Path file;
    final _OutputJob outJob;

    if ((attributes != null) && (attributes.isDirectory())) {
      file = PathUtils.createPathInside(
          path,
          ((archiveType != null) ? //
          (this.getArchiveFallbackFileName() + '.' + archiveType
              .getDefaultSuffix()) : //
              this.getDefaultPlainOutputFileName()));
      job.log("Path '" + path + //$NON-NLS-1$
          "' identifies a directory, creating file '" //$NON-NLS-1$
          + file + "' for output.");//$NON-NLS-1$
    } else {
      file = path;
    }

    try (final OutputStream fileOutput = PathUtils.openOutputStream(file)) {
      this._stream(job, data, fileOutput, encoding, archiveType);
    }

    if (archiveType != null) {
      outJob = ((_OutputJob) job);
      if (outJob.m_support != null) {
        outJob.m_support.addFile(file, archiveType);
      }
    }
  }

  /** {@inheritDoc} */
  @Override
  protected void path(final IOJob job, final S data, final Path path,
      final BasicFileAttributes attributes,
      final StreamEncoding<?, ?> encoding) throws Throwable {
    this._path(job, data, path, attributes, encoding, null);
  }

  /** {@inheritDoc} */
  @Override
  final void _stream(final IOJob job, final S data,
      final OutputStream stream, final StreamEncoding<?, ?> encoding,
      final EArchiveType archiveType) throws Throwable {
    String name;

    if (archiveType != null) {
      name = this.getDefaultPlainOutputFileName();
      if (job.canLog()) {
        job.log("Creating " + archiveType.getName() + //$NON-NLS-1$
            " output with file '" + name //$NON-NLS-1$
            + "' as the data (and only) file in the compressed stream."); //$NON-NLS-1$
      }
      try (final OutputStream output = archiveType.compressStream(stream,
          this.getArchiveFallbackFileName())) {
        this.__stream(job, data, output, encoding);
      }
    } else {
      this.__stream(job, data, stream, encoding);
    }
  }

  /**
   * Store the data element to a stream
   * 
   * @param job
   *          the job where logging info can be written
   * @param data
   *          the data to be written
   * @param stream
   *          the stream
   * @param encoding
   *          the encoding
   * @throws Throwable
   */
  private final void __stream(final IOJob job, final S data,
      final OutputStream stream, final StreamEncoding<?, ?> encoding)
      throws Throwable {
    Class<?> clazz;

    if ((encoding != null) && (encoding != StreamEncoding.UNKNOWN)
        && (encoding != StreamEncoding.TEXT)
        && (encoding != StreamEncoding.BINARY)
        && ((clazz = encoding.getOutputClass()) != null)
        && OutputStream.class.isAssignableFrom(clazz)) {
      if (job.canLog(IOJob.FINE_LOG_LEVEL)) {
        job.log(IOJob.FINE_LOG_LEVEL,
            "Using byte stream encoding " + encoding.name()); //$NON-NLS-1$
      }
      try (OutputStream encoded = ((OutputStream) (encoding
          .wrapOutputStream(stream)))) {
        this.stream(job, data, encoded, StreamEncoding.UNKNOWN);
      }
    } else {
      this.stream(job, data, stream, encoding);
    }
  }

  /**
   * Store the data element to a stream
   * 
   * @param job
   *          the job where logging info can be written
   * @param data
   *          the data to be written
   * @param stream
   *          the stream
   * @param encoding
   *          the encoding
   * @throws Throwable
   */
  protected void stream(final IOJob job, final S data,
      final OutputStream stream, final StreamEncoding<?, ?> encoding)
      throws Throwable {
    //
  }

  /** {@inheritDoc} */
  @SuppressWarnings({ "unchecked", "rawtypes" })
  @Override
  public IStreamOutputJobBuilder<S> use() {
    this.checkCanUse();
    return new _StreamOutputJobBuilder(this);
  }
}
